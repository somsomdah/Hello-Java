# Hello-Java

## 자바 : 클래스의 이해와 객체지향 프로그래밍
   <details>
     <summary> 클래스의 이해와 기초</summary>
     <div>

# 클래스의 이해와 기초
### 01. 클래스의 개념

### 02. 패키지의 개념

### 03. 오버로딩

### 04. 생성자

### 05. 메모리 모델
- 자바 가상머신(JVM)은 운영체제 위에서 동작한다
- JVM은 운영체제로부터 할당받은 메모리 공간을 이용해서 자기 자신도 실행을 하고, 자바 프로그램도 실행을 한다.
- JVM의 메모리 모델 : 메소드 영역 / 스택 영역 / 힙 영역
   - Method Area
      - Method bite code, Static variable
      - Bitecode : JVM에 의해 실행되는 코드, 고급언어 -(컴파일)-> 바이트코드 -(JVM)-> 기계어
      - 이 영역에 저장된 내용은 프로그램 시작 전에 로드되고 프로그램 종료시 소멸된다.
   - Stack Area
      - Local variable, Parameter
      - 프로그램이 실행되는 도중에 임시로 할당되었다가 해당 변수가 선언된 매소드 종료시 소멸
      - 스택의 흐름
         - 지역변수는 스택에 할당된다
         - 스택에 할당된 지역변수는 해당 메서드를 빠져 나가면 소멸된다
         - 할당 및 소멸의 특성상 메서드 별 스택이 구분이 된다  
   - Heap Area
      - Instance(Object)
      - 객체가 생성되는 메모리 공간
      - JVM에 의한 메모리 공간의 정리(Garbage Collection)가 이루어지는 공간
      - 할당은 프로그래머가, 소멸은 JVM이 처리
      - 참조변수에 의한 참조가 전혀 이루어지지 않은 인스턴스가 소멸의 대상이 된다
      
            '''java
            String str=new String("My String")
            str=null // 인스턴스가 사라지는 것이 아닌 참조 관계가 소멸 
            // -> 참조관계가 소멸된 인스턴스는 garbage collection의 다생이 된다
            '''
      - 따라서 JVM은 인서턴스의 참조관계를 확인하고 소멸할 대상을 선택한다
      - Garbage Collection
         - GC는 한번도 발생하지 않을 수 있다
         - GC가 발생하면 소멸의 대상이 되는 인스턴스는 결정되지만 이것이 실제 소멸로 바로 이어지지는 않는다
         - 인스턴스의 실제 소멸이 이루어지지 않은 상태에서 프로그램이 종료될 수도 있는데 그렇다면 OS차원에서 어차피 인스턴스는 소멸이 된다.
         - `System.gc()` : GC 명령 / `System.runFinalization()` : GC에 의해 소멸이 결정된 인스턴스를 즉시 소멸하라!
  
  
  
### 06. 접근 제한자 (Access Modifier)
  
   #### 1) 클래스 정의 대상의 접근 제한자 선언
   - public - 어디서든 인스턴스 생성이 가능
   - default - 동일 패키지로 묶인 클래스 내에서만 인스턴스 생성 허용
     
   #### 2)변수와 메서드 대상의 접근제한자 선언
   - public : 모두 접근 가능
   - protected : 상속받은 클래스 접근 가능
   - default : 동일 패키지에서만 접근 가능
   - private : 같은 클래스 내부에서만 접근 가능
 
     </div>
  </details>

<details>
   <summary> 상속과 활용</summary>
   <div>
    
# 상속과 활용

### 07. 상속
- 상위클래스의 모든 것이 하위클래스에게 전달되는 것을 뜻한다
- 그러나 상위클래스의 멤버변수와 멤버함수중 private으로 접근제한이 된 경우에는 하위클래스로 전달이 되지 않는다
- 장점 : 재사용성 증대, 확장 용이, 유지보수 용이
- `extends`를 사용하여 상속 구현 : `class Child extends Parent{ ~~ }`
- Java에서 다중상속은 허용되지 않음
- `super.method()` : 상위 클래스의 `method`라는 함수 호출

  
### 08. 오버라이딩
- 상속된 메서드와 동일한 이름, 동일한 인수를 가지는 메서드를 정의하여 상위 클래스의 메서드를 덮어쓰는 것
- 반환값의 형도 같아야 한다
- 하위클래스에서 상속 받은 메서드를 재정의하여 다른 연산을 수행하고 싶을 때 사용
- 기능의 변경, 기능의 추가
- 오버라이드는 추상클래스와 합쳐져서 객체지향 방법론에서 장점으로 많이 거론되는 확장성을 실현하는데 많은 도움을 줌
- `@override` : http://www.gisdeveloper.co.kr/?p=1265  
  
__오버라이딩 vs 오버로딩__
- 오버라이딩 : 상속 관계에서 발생, 하위클래스에서 상위클래서의 메서드를 재정의하는 것
- 오버로딩 : 한 클래스 내에서 동일한 이름의 매서드가 여러개 존재할 때

### 09. 스태틱
- 필드와 메서드에 붙이는 제한자
- static을 붙인 멤버(필드, 메서드)의 특징
   - 프로그램 시작 전에 메모리에 로딩된다
   - 객체를 생성하지 않고도 필드, 메서드 사용 가능
   - 이 때, 다를 객체를 참조하기 위해서는 객체 이름이 아닌 클래스명 지정
- 같은 클래스에서 생성된 객체는 static을 붙인 필드의 값을 공유한다
   ```java
   Class A{
      static int a;
   }
   ...
      A.a1=new A();
      A.a2=new A();
   ...
      a1.a=50
      a2.a=10
      // a의 값은 10
   ```
- static을 붙인 메서드
   - 어떤 객체에서도 같은 동작을 하는 메서드는 static을 붙여주는 것이 좋다 : 한 번만 생성되기 때문
   - static 메서드는 오버라이딩 할 수 없다
   - static 메서드에서 동일한 객체 내의 멤버(필드, 메서드)를 이용하기 위해서는 맴버에게 static을 붙여야만 한다.

### 10. 추상클래스

### 11. 인터페이스

### 12. 다형성
   </div>
</details>

<details>
   <summary> 클래스 활용</summary>
   <div>
    
# 클래스 활용

### 14. 은닉화

### 15. 객체 확인

### 16. Class 클래스

### 17. 절차지향 및 객체지향
   </div>
</details>

